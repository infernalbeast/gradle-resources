[compileJava, compileTestJava]*.options.collect {options ->
	options.compilerArgs.add '-parameters'
}

if (project.hasProperty("resourcesComment")) {
	resourcesComment {
		sourceSets.forEach { sourceSet ->
			def compileJava = tasks.findByName(sourceSet.compileJavaTaskName)
			def dstDir = new File(new File(buildDir, "resources-comment"), sourceSet.name)
			def task = create sourceSet, dstDir
			sourceSet.output.dir(dstDir, buildBy: task.name)
			compileJava.finalizedBy task
		}
	}
}

if (project.hasProperty("artifactoryClasspath")) {
	artifactoryClasspath {
		tasks.create(name: "mainRuntimeClasspathLedger", type: ledgerTaskClass) {
			// Required: The source set to be modified
			sourceSet = sourceSets.findByName("main")
			// Required: The configuration which to extract the dependencies
			configuration = configurations.findByName("runtimeClasspath")
			// Optional: The default number of retries when downloading before failing
			retry = 5
			// Optional: The default user artifact directory
			// artifactDirectory = ".classloader"
			// Optional: The credentials use use when accessing the artifactories
//			credentials = [
//				// Should match the name of the gradle repository being used
//				MavenRepo: [
//					// Get the credentials from various sources
//					// If environment and system are not defined,
//					// it will ask the user at runtime.
//					username: [
//						environment: "MAVEN_USERNAME",
//						system: "mavenUsername"
//					],
//					password: [
//						environment: "MAVEN_PASSWORD",
//						system: "mavenPassword"
//					]
//				]
//			]
		}
	}
}

apply from: rootProject.ext["gradle-resources"] + "thin-client.gradle", to: {
	setJarTask jar
}

if (project.hasProperty("resourcesRegex")) {
	resourcesRegex {
		sourceSets.forEach { sourceSet ->
			def compileJava = tasks.findByName(sourceSet.compileJavaTaskName)
			def dstDir = new File(new File(buildDir, "resources-regex"), sourceSet.name)
			def task = create sourceSet, dstDir
			sourceSet.output.dir(dstDir, buildBy: task.name)
			compileJava.finalizedBy task
		}
	}
}

if (project.hasProperty("classesDynamic")) {
	classesDynamic {
		sourceSets.forEach { sourceSet ->
			def compileJava = tasks.findByName(sourceSet.compileJavaTaskName)
			def dstDir = new File(new File(buildDir, "classes-dynamic"), sourceSet.name)
			def task = create sourceSet, dstDir
			sourceSet.output.dir(dstDir, buildBy: task.name)
			compileJava.finalizedBy task
		}
	}
}

if (System.env.ECLIPSE) {
	dependencies {
		sourceSets.main.java.srcDirs.each { dir ->
			if (dir.exists()) {
				logger.lifecycle "ADDING: " + dir
				def link = new File(dir.getParentFile(),dir.getName()+"-link")
				if (!link.exists()) {
					ant.symlink(resource: dir, link: link)
				}
				if (configurations.implementation.state == Configuration.State.UNRESOLVED) {
					implementation files(link)
				}
			}
		}
		sourceSets.test.java.srcDirs.each { dir ->
			if (dir.exists()) {
				logger.lifecycle "ADDING: " + dir
				def link = new File(dir.getParentFile(),dir.getName()+"-link")
				if (!link.exists()) {
					ant.symlink(resource: dir, link: link)
				}
				testImplementation files(link)
			}
		}
	}
}

eclipse {
	// This will add the source as a dependency if eclipse is making the request
	// Otherwise expect a gradle plugin to make the necessary resources available
	classpath {
		downloadJavadoc = true
		downloadSources = true
	}
	// https://discuss.gradle.org/t/how-to-write-properties-to-3rd-party-eclipse-settings-files/6499/2

	def props = new Properties()
	file(".settings").mkdirs()
	def prefs = file(".settings/org.eclipse.jdt.core.prefs")
	if (prefs.exists()) {
		prefs.withInputStream { stream ->
			props.load(stream)
		}
	}
	props.setProperty("org.eclipse.jdt.core.compiler.codegen.methodParameters", "generate")
	prefs.withOutputStream { stream ->
		props.store(stream, null)
	}
}

apply from: rootProject.ext["gradle-resources"] + "substitute.gradle"
