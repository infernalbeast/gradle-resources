[compileJava, compileTestJava]*.options.collect {options ->
	options.compilerArgs.add '-parameters'
}

if (project.hasProperty("resourcesComment")) {
	resourcesComment {
		sourceSets.forEach { sourceSet ->
			def compileJava = tasks.findByName(sourceSet.compileJavaTaskName)
			def dstDir = new File(new File(buildDir, "resources-comment"), sourceSet.name)
			def task = create sourceSet, dstDir
			sourceSet.output.dir(dstDir, buildBy: task.name)
			compileJava.finalizedBy task
		}
	}
}

if (project.hasProperty("artifactoryClasspath")) {
	artifactoryClasspath {
		// The output resource directory for META-INF
		// outputDirectory = new File(new File(buildDir, "artifactory-classpath"), sourceSet.name)
		task thinClient(type: artifactoryClasspathTaskClass) {
			// Required: The source set to be modified
			sourceSet = sourceSets.findByName("main")
			// Required: The task which generates the executable jar
			jar = tasks.findByName("jar")
			// Required: The configuration which to extract the dependencies
			configuration = configurations.findByName("runtimeClasspath")
			// Optional: The default number of retries when downloading before failing
			retry = 5
			// Optional: The default user artifact directory
			artifactDirectory = ".classloader"
			// Optional: The credentials use use when accessing the artifactories
			credentials = [
				BintrayJCenter: [
					environmentUsername: "JCENTER_USERNAME",
					environmentPassword: "JCENTER_PASSWORD"
				],
				JFrog: [
					systemUsername: "jfrogUser",
					systemPassword: "jfrogPassword"
				],
				MavenCentral: [
					username: "literalusername",
					password: "literalpassword"
				]
			]
		}
	}
}

if (project.hasProperty("resourcesRegex")) {
	resourcesRegex {
		sourceSets.forEach { sourceSet ->
			def compileJava = tasks.findByName(sourceSet.compileJavaTaskName)
			def dstDir = new File(new File(buildDir, "resources-regex"), sourceSet.name)
			def task = create sourceSet, dstDir
			sourceSet.output.dir(dstDir, buildBy: task.name)
			compileJava.finalizedBy task
		}
	}
}

if (project.hasProperty("classesDynamic")) {
	classesDynamic {
		sourceSets.forEach { sourceSet ->
			def compileJava = tasks.findByName(sourceSet.compileJavaTaskName)
			def dstDir = new File(new File(buildDir, "classes-dynamic"), sourceSet.name)
			def task = create sourceSet, dstDir
			sourceSet.output.dir(dstDir, buildBy: task.name)
			compileJava.finalizedBy task
		}
	}
}

if (System.env.ECLIPSE) {
	dependencies {
		sourceSets.main.java.srcDirs.each { dir ->
			if (dir.exists()) {
				logger.lifecycle "ADDING: " + dir
				def link = new File(dir.getParentFile(),dir.getName()+"-link")
				if (!link.exists()) {
					ant.symlink(resource: dir, link: link)
				}
				if (configurations.implementation.state == Configuration.State.UNRESOLVED) {
					implementation files(link)
				}
			}
		}
		sourceSets.test.java.srcDirs.each { dir ->
			if (dir.exists()) {
				logger.lifecycle "ADDING: " + dir
				def link = new File(dir.getParentFile(),dir.getName()+"-link")
				if (!link.exists()) {
					ant.symlink(resource: dir, link: link)
				}
				testImplementation files(link)
			}
		}
	}
}

eclipse {
	// This will add the source as a dependency if eclipse is making the request
	// Otherwise expect a gradle plugin to make the necessary resources available
	classpath {
		downloadJavadoc = true
		downloadSources = true
	}
	// https://discuss.gradle.org/t/how-to-write-properties-to-3rd-party-eclipse-settings-files/6499/2

	def props = new Properties()
	file(".settings").mkdirs()
	def prefs = file(".settings/org.eclipse.jdt.core.prefs")
	if (prefs.exists()) {
		prefs.withInputStream { stream ->
			props.load(stream)
		}
	}
	props.setProperty("org.eclipse.jdt.core.compiler.codegen.methodParameters", "generate")
	prefs.withOutputStream { stream ->
		props.store(stream, null)
	}
}

apply from: rootProject.ext["gradle-resources"] + "substitute.gradle"
